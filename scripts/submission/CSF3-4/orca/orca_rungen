#!/usr/bin/python3


#############################################
######## Create Orca SLURM runscript ##########
#############################################
# Author: Tim Renningholtz
# Date: 27.09.2024
# Description: This script creates a SLURM runscript for Orca 5.0.4 or 6.0.0-avx2
# on the CSF4 cluster.

#### Imports ####

import os
import sys
import argparse
import re

#### Create parser ####

parser = argparse.ArgumentParser(description="Create Orca slurm runscript")
parser.add_argument("-i", "--input", help="Input file name", required=True, type=str)
parser.add_argument(
    "-n",
    "--nodes",
    help="Number of nodes. multicore=1, multinode>1, serial=0; default=1",
    default=1,
    type=int,
)
parser.add_argument(
    "-cpg",
    "--cores_per_group",
    help="Number of cores per group",
    required=False,
    type=int,
    default=1,
)
parser.add_argument("-c", "--cores", help="Number of cores", required=True, type=int)
parser.add_argument(
    "-nbo",
    "--nbo",
    help="Request NBO module; needed only if nbo analysis is requested in input file",
    action="store_true",
)
parser.add_argument(
    "-o5",
    "--orca5",
    help="Request Orca 5 module; default is Orca6",
    action="store_true",
)
args = parser.parse_args()

#### Check parser arguments ####

# check if number of nodes is valid
if args.nodes > 1:
    queue = "multinode"
else:
    queue = "multicore"

if args.cores > 40 and args.nodes < 2:
    print("Number of cores must be between 2 and 40")
    sys.exit()
elif args.nodes == 0:
    queue = "serial"


# check orca and nbo modules
if args.orca5 and args.cores_per_group != 1:
    sys.exit("Orca 5 does not support cores per group")
elif args.orca5:
    orca_module = "module load orca/5.0.4-gompi-2021a"
else:
    orca_module = "module load rhel apps/binapps/orca/6.0.0-avx2"

if args.nbo and not args.orca5:
    nbo_module = """module load nbo/7.0.8-i8
export NBOEXE="/opt/software/RI/non-eb/apps/binapps/nbo/7.0.8/bin/nbo7.i8.exe"
export GENEXE="/opt/software/RI/non-eb/apps/binapps/nbo/7.0.8/bin/gennbo.i8.exe"

    """
elif args.nbo and args.orca5:
    nbo_module = """module load nbo/7.0.8-i4
export NBOEXE="/opt/software/RI/non-eb/apps/binapps/nbo/7.0.8/bin/nbo7.i4.exe"
export GENEXE="/opt/software/RI/non-eb/apps/binapps/nbo/7.0.8/bin/gennbo.i4.exe"

    """
else:
    nbo_module = ""


#### Define functions ####


# check if number of cores is the same as in input file
def check_cores_and_mem(input_file: str, c: int, cpg: int) -> None:
    """Function that checks number of cores in input file and adjusts if necessary.

    Args:
        input_file (str): Name of input file
        c (int): number of cores specified by user in cli
        cpg (int): number of cores per group specified by user in cli
    """
    with open(input_file, "r") as f:
        lines = f.read()

    if int(c) % int(cpg) != 0:
        print("Number of cores must be divisible by number of cores per group")
        sys.exit()
    # check for maxcore in input file
    mem_reg = re.compile(r"\%maxcore\s*(\d+)")
    last_input_line_reg = re.compile(r"!\s*(.*)")
    # get line with last occurence of !
    last_input_line = last_input_line_reg.findall(lines)[-1]
    try:
        mem = mem_reg.search(lines).group(1)
    except AttributeError:
        mem = 4096
        new_string = last_input_line + f"\n\n%maxcore {mem}"
        lines = lines.replace(last_input_line, new_string)
        print("Warning: %maxcore has been added to your input file.")

    # adjust maxcore if necessary
    if int(mem) != 4096:
        mem = 4096
        lines = re.sub(mem_reg, f"%maxcore {mem}", lines)
        print("Warning: %maxcore has been set to 4096.")

    # check if pal block is in input file
    pal_reg = re.compile(r"\%pal")
    if not pal_reg.search(lines) and args.cores:
        print("Your input file does not contain a %pal block but you have requested cores.")
        add_pal = input("Do you want to add a %pal block to your input file? (Y/n)").capitalize()
        if add_pal == "N":
            sys.exit()

        lines = re.sub(
            mem_reg, f"%maxcore {mem}\n\n%pal\nend", lines
        )

        if not args.orca5:
            lines = re.sub(
                r"\%pal",
                f"%pal\n\tnprocs {c}\n\tnprocs_group {cpg}",
                lines,
            )
        else:
            lines = re.sub(r"\%pal", f"%pal\n\tnprocs {c}", lines)

        print("Warning: %pal block has been added to your input file.")

    cores_reg = re.compile(r"nprocs\s*(\d+)")
    cores = cores_reg.search(lines).group(1)
    cores_per_group_reg = re.compile(r"nprocs_group\s*(\d+)")
    # check if cores per group is in input file
    if not args.orca5:
        try:
            cores_per_group = cores_per_group_reg.search(lines).group(1)
        except AttributeError:
            # add nprocs_group to input file after nprocs
            lines = re.sub(r"\s*nprocs\s*\d+", f"\tnprocs {c}\n\tnprocs_group {cpg}", lines)
            print("Warning: nprocs_group has been added to your input file.")
            cores_per_group = cpg
    else:
        try:
            print("Warning: nprocs_group is not supported in Orca 5.")
            cores_per_group = cores_per_group_reg.search(lines).group(1)
            # remove nprocs_group from input file
            lines = re.sub(r"\s*nprocs_group\s*\d+", "", lines)
            print("Warning: nprocs_group has been removed from your input file.")
        except AttributeError:
            cores_per_group = 1

    # check if number of cores in input file matches number of cores specified
    if int(cores) != c or int(cores_per_group) != cpg and not args.orca5:
        print("Your input file does not match number of cores specified")
        # ask user if they want to change number of cores in input file with yes as default
        change_cores = input(
            "Do you want to change the number of cores in the input file occording to your cli input? (Y/n)"
        ).capitalize()
        if change_cores == "N":
            sys.exit()
        with open(input_file, "w") as f:
            string1 = re.sub(cores_reg, f"nprocs {c}", lines)
            f.write(re.sub(cores_per_group_reg, f"nprocs_group {cpg}", string1))
        print("Warning: Your input file has been modified.")
    elif int(cores) != c and args.orca5:
        print("Your input file does not match number of cores specified")
        change_cores = input(
            "Do you want to change the number of cores in the input file occording to your cli input? (Y/n)"
        ).capitalize()
        if change_cores == "N":
            sys.exit()
        with open(input_file, "w") as f:
            string1 = re.sub(cores_reg, f"nprocs {c}", lines)
            f.write(string1)
        print("Warning: Your input file has been modified.")
    else:
        with open(input_file, "w") as f:
            f.write(lines)
    return


# create slurm runscript
def create_runscript(queue, cores, input_file, nbo):
    script = (
        """#!/bin/bash --login
#SBATCH -p {}       # (or --partition=) Parallel job using cores on a single node
#SBATCH -n {}                # (or --ntasks=) Number of cores (2--40)
#SBATCH --job-name {}""".format(
            queue, cores, input_file.split(".")[0]
        )
        + """
###########################
job=${SLURM_JOB_NAME}

job=$(echo ${job%%.*})
##########################

# Load the modulefile in a clean environment
module purge"""
        + "\n"
        + orca_module
        + "\n"
        + nbo
        + """

export RSH_COMMAND=ssh
##########################
export scratchlocation=/scratch

if [ ! -d $scratchlocation/$USER ]

then

  mkdir -p $scratchlocation/$USER

fi
##########################
tdir=$(mktemp -d $scratchlocation/$USER/orcajob_$SLURM_JOB_ID-XXXX)

# Copy only the necessary stuff in submit directory to scratch directory. Add more here if needed.

cp  $SLURM_SUBMIT_DIR/*.inp $tdir/

cp  $SLURM_SUBMIT_DIR/*.gbw $tdir/

cp  $SLURM_SUBMIT_DIR/*.cmp $tdir/

cp  $SLURM_SUBMIT_DIR/*.hess $tdir/

cp  $SLURM_SUBMIT_DIR/*.xyz $tdir/
#########################

# Creating nodefile in scratch

# echo $SLURM_NODELIST > $tdir/$job.nodes

# cd to scratch

cd $tdir

# Copy job and node info to beginning of outputfile

echo "Job execution start: $(date)" >>  $SLURM_SUBMIT_DIR/$job.out

echo "Shared library path: $LD_LIBRARY_PATH" >>  $SLURM_SUBMIT_DIR/$job.out

echo "Slurm Job ID is: ${SLURM_JOB_ID}" >>  $SLURM_SUBMIT_DIR/$job.out

echo "Slurm Job name is: ${SLURM_JOB_NAME}" >>  $SLURM_SUBMIT_DIR/$job.out

echo $SLURM_NODELIST >> $SLURM_SUBMIT_DIR/$job.out

#Start ORCA job. ORCA is started using full pathname (necessary for parallel execution). Output file is written directly to submit directory on frontnode.

$(which orca) $job.inp >  $SLURM_SUBMIT_DIR/$job.out

# ORCA has finished here. Now copy important stuff back (xyz files, GBW files etc.). Add more here if needed.

cp $tdir/*.gbw $SLURM_SUBMIT_DIR

cp $tdir/*.engrad $SLURM_SUBMIT_DIR

cp $tdir/*.xyz $SLURM_SUBMIT_DIR

cp $tdir/*.loc $SLURM_SUBMIT_DIR

cp $tdir/*.qro $SLURM_SUBMIT_DIR

cp $tdir/*.uno $SLURM_SUBMIT_DIR

cp $tdir/*.unso $SLURM_SUBMIT_DIR

cp $tdir/*.uco $SLURM_SUBMIT_DIR

cp $tdir/*.hess $SLURM_SUBMIT_DIR

cp $tdir/*.cis $SLURM_SUBMIT_DIR

cp $tdir/*.dat $SLURM_SUBMIT_DIR

cp $tdir/*.mp2nat $SLURM_SUBMIT_DIR

cp $tdir/*.nat $SLURM_SUBMIT_DIR

cp $tdir/*.scfp_fod $SLURM_SUBMIT_DIR

cp $tdir/*.scfp $SLURM_SUBMIT_DIR

cp $tdir/*.scfr $SLURM_SUBMIT_DIR

cp $tdir/*.nbo $SLURM_SUBMIT_DIR

cp $tdir/FILE.47 $SLURM_SUBMIT_DIR

cp $tdir/*_property.txt $SLURM_SUBMIT_DIR

cp $tdir/*json* $SLURM_SUBMIT_DIR

cp $tdir/*.err $SLURM_SUBMIT_DIR

cp $tdir/*spin* $SLURM_SUBMIT_DIR"""
    )
    return script


# check if input file exists
if not os.path.isfile(args.input):
    print("Input file does not exist")
    sys.exit()
# if input file exists, create slurm runscript and adjust number of cores
else:
    # check if number of cores in input file matches number of cores specified
    check_cores_and_mem(args.input, args.cores, args.cores_per_group)
    with open("run.sh", "w") as f:
        f.write(create_runscript(queue, args.cores, args.input, nbo_module))